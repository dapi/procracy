# Закон 005. Об идентификации и аутентификации

> Уровень: Закон (60%+ голосовавших, 5 дней cooling, x2 залог)
> Статус: драфт

---

## Раздел 1. Криптографическая идентификация

1.1. Каждый гражданин PRocracy идентифицируется парой криптографических ключей.
1.2. Алгоритм подписи: **Ed25519** (RFC 8032).
1.3. Пара ключей состоит из приватного ключа (32 байта, хранится у гражданина)
     и публичного ключа (32 байта, публикуется в заявлении на гражданство).
1.4. Публичный ключ в заявлении указывается в кодировке **base64** (44 символа).
1.5. Гражданин генерирует пару ключей самостоятельно.

## Раздел 2. Регистрация публичного ключа

2.1. Публичный ключ указывается в заявлении на гражданство (поле `public_key`).
2.2. Заявление без публичного ключа не принимается.
2.3. Один публичный ключ может быть привязан только к одному гражданину.
2.4. Сервер отклоняет регистрацию дублирующего ключа.

## Раздел 3. Подпись API-запросов

3.1. Каждый запрос к API должен содержать HTTP-заголовки аутентификации:
     - `X-Citizen` — GitHub username гражданина
     - `X-Timestamp` — время запроса в формате ISO 8601 (UTC)
     - `X-Signature` — подпись в кодировке base64

3.2. Подписываемое сообщение формируется по шаблону:

```
{method}\n{path}\n{timestamp}\n{body_hash}
```

Где:
- `method` — HTTP-метод заглавными буквами (GET, POST, PUT, DELETE)
- `path` — путь запроса (без хоста, включая query string)
- `timestamp` — значение заголовка `X-Timestamp`
- `body_hash` — SHA-256 хеш тела запроса в hex; для пустого тела — SHA-256 пустой строки

3.3. Подпись создаётся приватным ключом Ed25519 над UTF-8 байтами сообщения.
3.4. Сервер верифицирует подпись публичным ключом из файла гражданства.

## Раздел 4. Защита от replay-атак

4.1. Сервер принимает запросы с `X-Timestamp` в пределах **±5 минут** от серверного времени.
4.2. Запросы за пределами окна отклоняются с ошибкой `401 Timestamp expired`.
4.3. Опционально клиент может добавить заголовок `X-Nonce` (UUID v4).
4.4. Если `X-Nonce` указан, сервер отклоняет повторное использование nonce
     в пределах временного окна.

## Раздел 5. Ротация ключей

5.1. Гражданин может заменить свой публичный ключ через PR,
     обновляющий файл `citizenship/<username>.md`.
5.2. Такой PR имеет уровень "Код" (ст. 8.1 Конституции).
5.3. После принятия PR старый ключ немедленно перестаёт действовать.
5.4. Сервер использует только последний принятый ключ.

## Раздел 6. Компрометация ключа

6.1. При подозрении на компрометацию гражданин обязан:
     1. Создать Issue с меткой `key-compromised`
     2. Подать PR с новым публичным ключом
6.2. Администраторы могут экстренно заблокировать скомпрометированный ключ
     до принятия PR.
6.3. Действия, совершённые скомпрометированным ключом после подачи Issue,
     могут быть оспорены.

## Раздел 7. Примеры генерации ключей

### OpenSSL

```bash
# Генерация приватного ключа
openssl genpkey -algorithm Ed25519 -out private.pem

# Извлечение публичного ключа
openssl pkey -in private.pem -pubout -out public.pem

# Получение raw 32 байт публичного ключа в base64
openssl pkey -in private.pem -pubout -outform DER | tail -c 32 | base64
```

### Python (PyNaCl)

```python
from nacl.signing import SigningKey
import base64

private_key = SigningKey.generate()
public_key = private_key.verify_key
print(base64.b64encode(bytes(public_key)).decode())
```

### Node.js

```javascript
import { generateKeyPairSync } from 'node:crypto';

const { publicKey, privateKey } = generateKeyPairSync('ed25519');
const rawPub = publicKey.export({ type: 'spki', format: 'der' }).subarray(-32);
console.log(rawPub.toString('base64'));
```
